First we scan the ACPI Header to get information on the system, eg amount of ap, io-apic base, apic base...
Then we setup up the APIC and enable it
Then we setup ioapic








Brendan at osdev.org:
When a CPU receives the "INIT IPI", it has to reset itself to a default state
(including wiping its caches, invalidating TLBs, MTRRs, etc).
This takes time. Different CPUs probably take different amounts of time
- e.g. slow CPUs with very little internal state might be able to reset themselves quickly;
and fast CPUs with a lot of internal state  (branch buffers, streaming loop detectors, AVX, etc) might take far longer to reset.
If a CPU receives a SIPI while it's resetting it's internal state, it can't store the fact that its received the SIPI in the internal state that it's in the middle of resetting.
To fix that; Intel have given us a guarantee.
They've mostly said "all CPUs will take less than 10 ms to restore themselves to default state after receiving an INIT IPI".
This means an OS has to wait 10 ms after sending the INIT IPI to be sure the CPU has had the time it needs to be ready to receive the SIPI IPI.

For the 200 us delays, this is probably similar - a guarantee from Intel that all CPUs will be able to fetch their first instruction from RAM into cache and start executing within 200 us.
This is likely to be "conservative' - e.g. enough time for the CPU to execute several instructions and set some sort of flag (to inform whoever started it that it actually did start).

Also note that most CPUs do start on the first SIPI, where the second SIPI "re-starts" it; and I suspect that the second SIPI is only there just in case the first was lost. For my code, if the AP CPU has already set some sort of "I'm running" flag after the first SIPI, then I skip the second SIPI and the second delay.

For the second SIPI; that delay should not be a delay but should be a time-out. E.g. "while( (AP_CPU_started_flag_not_set_by_AP) && (timeout_not_expired) ) { // Keep waiting }". If it is used as a time-out like this; then it should be much longer (e.g. 500 ms and not 200 us).







You'd need to (in order):
Parse ACPI 's "MADT/APIC" table to figure out how legacy ISA IRQs are connected to IO APIC inputs (and fall back to Intel's "MultiProcessor Specification" tables if there is no ACPI).
Mask all IRQs (not the "cascade" line) in the PIC chips
Mask everything in all IO APICs. You can "pre-setup" each IO APIC input while doing this. Note: there can be more than one IO APIC - e.g. a pair of IO APICs with 16 inputs each, or a set of four IO APICs, or....
Create (or make sure you already have) an IDT with interrupt vectors for the local APIC's spurious IRQ, the master PIC's spurious IRQ and the slave PIC's spurious IRQ.
For each CPU (in any order):
Set the local APIC's "Task Priority Register" to zero
Setup the local APIC's "Spurious Interrupt Vector Register" (give it a vector for the spurious IRQ, and enable the local APIC)
(Optional maybe) setup the local APIC's "Destination Format Register" for flat mode
(Optional maybe) setup the local APIC's "Logical Destination Register"
Do whatever ACPI and/or MP spec tables told you to do (if anything) with the local APIC's "LINT0" and "LINT1" interrupts
If ACPI and/or MP spec tables told you there's an IMCR, diddle the IMCR to switch from "PIC mode" to "IO APIC mode" (see MP spec for details)

Once that's done; when you initialise a device (e.g. PIT chip), after doing any resetting and/or self-testing you'd want to install a suitable interrupt handler for it in the IDT, and after that unmask its IRQ in the IO APIC (and not in any PIC chip).

Finally; when an interrupt does occur (excluding any of the spurious IRQs) you have to send an EOI to the local APIC's "EOI Register" (and not to any PIC chip).
