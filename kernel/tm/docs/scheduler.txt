The scheduling algorithm is a simplistic priority based Round Robin. There are multiple 'ready' queues with different priorities. Queues with higher priority are used more often than lower ones by RR scheduler tot select a new thread. For example imagine 3 threads A,B and C where A had the highest priority,  B has a normal priority and C the lowest. Then these threads will be executed in the following order:
      A-B-A-B-A-C
So every odd quantum a highest priority thread will be executed and every second and 6th quantum a medium priority and finally every 4th tick a lowest priority

current_thread: A-C-A-B-A-B- A-C-A-B-A-B- A-C-A-B-A-B
current_tick:      1-2-3-...

Executing a new thread is done by changing the current stack to the stack of the new thread. When a new thread is created its stack must contain all the necessary registers that will be popped when the scheduler starts executing this thread.





############
#Pseudo Code#
############

void timer_handler_asm(uint64_t rsp)
{
        (Push all regs except edi)
        (Push data selectors)
	mov eax, cr3
	push eax
        mov rdi, rsp ; system V ABI: rdi=first arg
        call timer_callback
        mov rsp, rax ; system V ABI: rax=return value
	pop eax
	mov cr3, eax
        (pop all regs except edi)
        (pop data selectors)
         send_eoi
         iretd
}

uint64_t timer_callback(uint64_t rsp)
{
current_tick++;
current_thread->rsp = rsp;
spinlock_lock();
add_thread_tot_end_of_que();
sched_find_next_thread();
spinlock_unlock();
return current_thread->rsp;
}

void sched_find_next_thread()
{
If(current_tick%2 && ready_que_high)
{
      current_thread = ready_que_highest;
      ready_que_highest = ready_que_highest->next;
}
else if(current_tick%6 && ready_que_lowest)
{
...
}
else if(ready_que_medium)
{
...
}
}
